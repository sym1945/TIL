## HTTPS vs HTTP ##
- HTTP는 **Hypertext Transfer Protocol**의 약자로 HTML을 전송하기 위한 통신 규약		
- HTTPS ```S```는 **Over Secure Socket Layer**의 약자로 보안이 강화된 HTTP		
## HTTPS와 SSL ##
- HTTP는 SSL 프로토콜 위에서 돌아가는 프로토콜		
- HTTP가 SSL을 이용하면 HTTPS		
## SSL과 TLS	##
- 네스케이프에서 발명된 SSL이 표준화되면서 TLS라는 이름으로 변경됨(SSL=TLS)		
- 공식적인 명칭은 TLS나 아직도 SSL이라는 이름으로 많이 사용되고 있음		
## SSL 디지털 인증서 ##
- 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서		
- SSL 디지털 인증서 사용시 이점		
  * 통신 내용이 공격자에게 노출되는 걸 막을 수 있음	
  * 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지 판단 가능	
  * 통신 내용의 악의적인 변경 방지 가능	
## SSL에서 사용하는 암호화 종류 ##
- 대칭키		
  * 키(key)란 암호화/복호화 할 때 필요한 일종의 패스워드	
  * 대칭키의 경우 암호화/복호화 시 같은 키가 필요함	
  * 암호화된 데이터를 주고 받을 때 암호화 되지 않은 키까지 주고 받아야하는 단점이 있음	
- 공개키		
  * 비공개키(private key)와 공개키(public key)를 한 쌍으로 함	
  * 공개키로 암호화하면 비공개키로 복호화 할 수 있고 비공개키로 암호화하면 공개키로 복화화 할 수 있음	
  * 공개키는 상대방에게 제공하고 비공개키는 개인이 보관	
  * 상대방에 데이터를 보낼때 상대방의 공개키로 암호화하여 보내면 상대방은 그들의 비공개키로 복호화 함	
  * 반대로 상대방은 내 공개키로 데이터를 암호화하고 나는 내 개인키로 복호화 함	
  * 비공개키로 암호화 할 경우 공개키를 알고 있으면 누구든 복호화 할 수 있음	
  * 사실 공개키 암호화 목적은 데이터 보호가 아닌 데이터를 제공한 사람의 신원을 보장하는 것에 있음(비공개키와 공개키가 쌍이라는 점을 통해)	
  * 이 신원 보장해주는 걸 전자 서명이라고 함	
## SSL 인증서 ##
- 인증서의 역할		
  * 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장	
  * SSL 통신에 사용할 공개키를 클라이언트에게 제공	
- CA (Certificate authority)		
  * 인증서를 발급해주는 민간기업	
  * SSL을 통해 암호화된 통신을 제공하려면 서비스는 CA를 통해 인증서를 구입해야 함	
- 사설 인증기관		
  * 개발 또는 사적인 목적으로 SSL 암호화 기능을 이용하기 위해 자신이 직접 CA 역할을 할 수도 있음	
  * 이는 공인된 인증서가 아니기 때문에 브라우저에서 유저에게 경고를 표시함	
- SSL 인증서 내용
```
  1) 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등)	
  2) 서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법)
```
위 내용들은 CA에 의해 공개키 방식으로 암호화 됨. (위에 서버가 제출한 인증서 내용을 CA의 비공개키로 암호화하여 인증서를 발급하는 것)	
- 브라우저는 CA를 알고 있음		
	* 브라우저는 내부적으로 CA 리스트를 파악하고 있음 (브라우저 개발사에서 업데이트를 통해 갱신)	
	* CA의 공개키를 이미 알고 있어서 CA에서 발급한 인증서를 복호화 할 수 있음	
- SSL 인증서가 서비스를 보증하는 방법		
  * 웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공	
  * 브라우저는 인증서의 CA가 자신이 갖고 있는 CA 리스트에 있는지 확인	
  * CA 리스트에 포함돼 있다면 해당 CA의 공개키로 인증서를 복호화	
  * 복호화에 성공했다는 것은 해당 인증서가 CA의 개인키로 암호화 했다는 것을 의미	
  * 이렇게 공인된 CA에서 발급한 인증서라는 것이 확인되면 해당 서비스는 신뢰할 수 있는 서비스로 보증 됨	
## SSL의 동작방법 ##
- SSL은 암호화된 데이터를 전송하기 위해 공개키와 대칭키를 혼합해서 사용함
- 주고 받는 데이터는 대칭키 방식으로 암호화하고, 복호화에 필요한 대칭키를 공개키 방식으로 암호화해서 전달함		
- ```Why?``` 공개키만으로 데이터를 암호화/복호화 할 경우 많은 컴퓨터 자원을 소모하기 때문		
- 이하 컴퓨터 간 네트워크 통신 중 SSL이 어떻게 동작하는지 단계적으로 설명
1. ***악수 (handshake)***
   - 실제 데이터 주고 받기 전 서로 상대방이 존재하는지,  상대방과 데이터를 주고 받기 위해 어떤 방법을 사용해야하는지 파악하는 단계
   1. **클라이언트 -> 서버**
      - 클라이언트 측에서 생성란 랜덤 데이터
      - 클라이언트가 지원하는 암호화 방식 리스트(이중 쓸 수 있는거 골라봐)
      - 세션 아이디
   2. **서버 -> 클라이언트**
	  - 서버측에서 생성한 랜덤 데이터
      - 서버가 선택한 클라이언트 암호화 방식(난 이걸 택했어)
	  - 인증서
   3. **클라이언트 측 인증서 확인 및 pre master secret 키 생성**
		- 서버의 인증서가 CA에서 발급한 것인지 확인(없을 경우 브라우저에서 경고 메시지)
		- 상기 양측에서 생성한 랜덤 데이터를 조합해 pre master secret 키 생성
		- pre master secret 키는 데이터를 주고 받을 때 사용될 대칭키가 됨
		- 클라이언트는 이 대칭키를 서버의 공개키로 암호화 해 서버측으로 전달
   4. **서버측 pre master secret 키 복호화 및 session key 생성**
      - 클라이언트로부터 전달받은 pre master secret을 복호화하며 양측 모두 대칭키를 갖게 됨
      - 양측은 일련의 과정을 거쳐 pre master secret을 master secret으로 만듬
      - 이 master secret은 session key를 생성하여 최종적으로 양측은 session key 값을 통해 대칭키 방식으로 데이터를 주고 받음
   5. **핸드쉐이크 종료**<br/><br/>
2. ***세션***
   - 서버와 클라이언트가 데이터를 주고 받는 단계	
   - session key 값을 이용해 대칭키 방식으로 데이터를 암호화 함<br/><br/>
3. ***세선종료***
   - 데이터 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려 줌	
   - 이 때 통신에 사용한 대칭키인 session key를 폐기함	

## 출처 ##
[HTTPS와 SSL 인증서 - 생활코딩](https://opentutorials.org/course/228/4894)
